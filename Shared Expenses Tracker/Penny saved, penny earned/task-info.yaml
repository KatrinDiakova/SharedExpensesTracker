type: edu
files:
- name: src/splitter/Main.java
  visible: true
  text: |
    package splitter;


    import java.util.*;

    public class Main {

        private static Scanner sc = new Scanner(System.in);

        public static void main(String[] args) {
            while (true) {
                String input = sc.nextLine();
                List<String> inputList = Arrays.asList(input.split(" "));
                CommandParser.parseUserInput(inputList);
            }
        }
    }
  learner_created: false
- name: src/splitter/CommandParser.java
  visible: true
  text: |
    package splitter;

    import java.math.BigDecimal;
    import java.util.*;

    public class CommandParser {

        private static Balance balance = new Balance();
        private static BorrowRepay borrowRepay = new BorrowRepay();
        private static Group group = new Group();
        private static Purchase purchase = new Purchase();
        private static Map<String, BigDecimal> balanceAmount = new HashMap<>();
        private static Map<String, ArrayList<BalanceHistory>> balanceHistory = new HashMap<>();

        static void parseUserInput(List<String> input) {
            if (input.contains("exit")) {
                System.exit(0);
            } else if (input.contains("help")) {
                printHelp();
            } else if (input.contains("borrow") || input.contains("repay")) {
                borrowRepay.parceData(input, balanceAmount, balanceHistory);
            } else if (input.contains("balance")) {
                balance.parceData(input, balanceAmount, balanceHistory);
            } else if (input.contains("group")) {
                group.parceData(input);
            } else if (input.contains("purchase")) {
                purchase.parceData(input, balanceAmount, balanceHistory);
            } else {
                System.out.println("Unknown command. Print help to show commands list");
            }
        }

        static void printHelp() {
            List<String> menu = List.of(
                    "balance",
                    "borrow",
                    "exit",
                    "group",
                    "help",
                    "purchase",
                    "repay"
            );

            for (String m : menu) {
                System.out.println(m);
            }
        }
    }
  learner_created: false
- name: test/SharedBillsSplitterTestStage6.java
  visible: false
  text: |-
    import org.hyperskill.hstest.dynamic.output.InfiniteLoopDetector;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testcase.SimpleTestCase;
    import org.hyperskill.hstest.testcase.TestCase;
    import org.hyperskill.hstest.testing.TestedProgram;
    import org.hyperskill.hstest.testing.execution.MainMethodExecutor;
    import org.junit.After;
    import org.junit.Before;

    import java.io.File;
    import java.io.IOException;
    import java.math.BigDecimal;
    import java.nio.file.Files;
    import java.nio.file.Path;
    import java.nio.file.Paths;
    import java.util.*;
    import java.util.concurrent.atomic.AtomicInteger;
    import java.util.function.BiFunction;
    import java.util.function.Predicate;
    import java.util.stream.Collectors;

    public class SharedBillsSplitterTestStage6 extends StageTest {

        public static final String FILTERED_BALANCE_FEEDBACK = "Program should output balance result for persons who contains if filter. However owes values should be the same as if balance were unfiltered.";
        public static final String BALANCE_PERFECT_FEEDBACK = "Your program should reduce repayments count for balancePerfect";
        private static final String UNKNOWN_COMMAND = "Unknown command";
        private static final String EXIT_ERROR = "Your program should stop after exit command";
        private static final String HELP_ERROR = "Help command should print all commands line by line in natural order";
        private static final String ILLEGAL_COMMAND_ARGUMENTS = "Illegal command arguments";
        private static final String ILLEGAL_ARGUMENTS_ERROR = "Your program should handle exceptions in incorrect command arguments input";
        private static final String UNKNOWN_GROUP = "Unknown group";
        private static final String NO_REPAYMENTS = "No repayments";
        private static final String WRONG_CALCULATIONS = "Wrong calculations. Program should output owes list that " +
                "if every person in this list repay his owes then everyone will have zero balance and everyone will be paid off";
        private static final String GIFT_TO = " gift to ";
        private static final String GROUP_PERSONS_FEEDBACK = "Persons in group should be printed line by line sorted in ascending order";
        private static final String BALANCE_OWES_FEEDBACK = "Owes should be sorted by Person who owes and Person whom owes";
        private static final String WRITE_OFF_FEEDBACK = "WriteOff should remove from storage all money operations till command date";
        private static final String INCORRECT_BALANCE = "The balance your program outputs is incorrect";
        private static final String INCORRECT_MONEY_FORMAT = "Money should be formatted with proper scale";
        private static final String EMPTY_GROUP = "Your program should output \"Group is empty\" if the purchase or show command is invoked on an empty group.";

        static {
            InfiniteLoopDetector.setWorking(false);
        }

        private final String databasePath;

        public SharedBillsSplitterTestStage6() {

            databasePath = "../testDB" + ".mv.db";
        }

        private static long getLinesCount(String balancePerfectResult) {

            return balancePerfectResult.lines()
                                       .filter(Predicate.not(String::isBlank))
                                       .count();
        }

        private static boolean isBalanceResultOk(String keyPerson, String result, BigDecimal sumBalance) {

            Optional<BigDecimal> sum = Arrays.stream(result.split("\n"))
                                             .filter(it -> it.contains(keyPerson))
                                             .map(it -> {
                                                 String[] split = it.split("\\s+");
                                                 Character sign = it.startsWith(keyPerson) ? '+' : '-';
                                                 return sign + split[split.length - 1];
                                             })
                                             .map(BigDecimal::new)
                                             .reduce(BigDecimal::add);
            return sumBalance.compareTo(sum.orElse(BigDecimal.ZERO)) == 0;
        }

        private static boolean equalsByLines(String sample, String linesStr) {

            List<String> sampleLines = strToLinesTrimmed(sample);
            List<String> lines = strToLinesTrimmed(linesStr);
            return sampleLines.equals(lines);
        }

        private static List<String> strToLinesTrimmed(String sample) {

            return sample.lines().map(String::trim).collect(Collectors.toList());
        }

        @Before
        public void doSomeBefore() {

            if (databasePath != null) {
                replaceDatabase();
            }
        }

        @After
        public void doSomeAfter() {

            if (databasePath != null) {
                revertDatabase();
            }
        }

        private void replaceDatabase() {

            String dbFilePath = System.getProperty("user.dir")
                    + File.separator + databasePath;

            String dbTempFilePath = dbFilePath + "-real";

            Path dbFile = Paths.get(dbFilePath);
            Path dbTempFile = Paths.get(dbTempFilePath);

            try {
                if (dbTempFile.toFile().exists()) {
                    Files.deleteIfExists(dbFile);
                } else if (dbFile.toFile().exists() && !dbTempFile.toFile().exists()) {
                    Files.move(dbFile, dbTempFile);
                }
            } catch (IOException ignored) {
            }
        }

        private void revertDatabase() {

            String dbFilePath = System.getProperty("user.dir")
                    + File.separator + databasePath;

            String dbTempFilePath = dbFilePath + "-real";

            Path dbFile = Paths.get(dbFilePath);
            Path dbTempFile = Paths.get(dbTempFilePath);

            try {
                Files.deleteIfExists(dbFile);
                if (dbTempFile.toFile().isFile()) {
                    Files.move(dbTempFile, dbFile);
                }
            } catch (IOException ignored) {
            }
        }

        private <T> TestCase<T> caseToDynamicTesting(TestCase<T> testCase) {

            String feedback = testCase.getFeedback();
            String input = testCase.getInput();
            T attach = testCase.getAttach();
            BiFunction<String, T, CheckResult> checkFunc = testCase.getCheckFunc();

            return new TestCase<T>()
                    .setFeedback(feedback)
                    .setDynamicTesting(() -> {
                        TestedProgram p = new TestedProgram();
                        ((MainMethodExecutor) p.getProgramExecutor()).setUseSeparateClassLoader(false);
                        p.setReturnOutputAfterExecution(false);
                        p.start();
                        p.execute(input);
                        return checkFunc.apply(p.getOutput(), attach);
                    });
        }

        @Override
        public List<TestCase> generate() {

            return List.of(

                    caseToDynamicTesting(new TestCase<String>()
                                                 .setCheckFunc(this::checkUnknownCommand)
                                                 .setAttach("someAttachText")
                                                 .setInput("someRandomText\n" +
                                                                   "exit")),

                    caseToDynamicTesting(new SimpleTestCase("repay Ann\n" +
                                                            "exit",
                                                            ILLEGAL_COMMAND_ARGUMENTS)
                                                 .setFeedback(ILLEGAL_ARGUMENTS_ERROR)),

                    caseToDynamicTesting(new TestCase<String>()
                                                 .setCheckFunc(this::checkHelpCommand)
                                                 .setInput(concatLines(Commands.help.toString(), Commands.exit.toString()))),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute(Commands.exit.toString());
                        if (!main.isFinished()) {
                            return CheckResult.wrong(EXIT_ERROR);
                        }
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute("borrow Ann Bob 1.00");
                        final String FUTURE_DATE = "3030.03.30";
                        main.execute(FUTURE_DATE + " purchase Bob coffee 3.50 (Bob, Ann)");
                        main.execute("writeOff");
                        { //1st
                            String result = main.execute("balance close");
                            if (!result.startsWith(NO_REPAYMENTS)) {
                                return CheckResult.wrong(WRITE_OFF_FEEDBACK);
                            }
                        }
                        { //2nd
                            main.execute(FUTURE_DATE + " writeOff");
                            String result = main.execute(FUTURE_DATE + " balance close");
                            if (!result.startsWith(NO_REPAYMENTS)) {
                                return CheckResult.wrong(WRITE_OFF_FEEDBACK);
                            }
                        }
                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        {
                            TestedProgram main = new TestedProgram();
                            ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                            main.start();
                            main.execute("writeOff");
                            main.execute("group create TEAM (Diana, Elon, Bob, Ann)");
                            main.execute("purchase Elon icecream 4.80 (TEAM)");
                            main.execute("borrow Ann Bob 1.05");
                            main.execute("repay Ann Bob 5.01");
                            main.execute("exit");
                        }
                        {
                            TestedProgram main = new TestedProgram();
                            ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                            main.start();
                            String groupResult = main.execute("group show TEAM");
                            if (!equalsByLines(groupResult, concatLines("Ann", "Bob", "Diana", "Elon"))) {
                                return CheckResult.wrong(GROUP_PERSONS_FEEDBACK + ". Also person and group should be stored in database");
                            }
                            String balanceResult = main.execute("balance close");
                            if (!equalsByLines(balanceResult, """
                                Ann owes Elon 1.20
                                Bob owes Ann 3.96
                                Bob owes Elon 1.20
                                Diana owes Elon 1.20""")) {
                                return CheckResult.wrong(BALANCE_OWES_FEEDBACK + " Also all payment operations should be stored in database");
                            }
                            main.execute("exit");
                        }
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        {
                            TestedProgram main = new TestedProgram();
                            ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                            main.start();
                            String output;
                            String[] words;

                            main.execute("writeOff");
                            main.execute("2020.09.30 borrow Ann Bob 20.10");
                            main.execute("2020.10.01 repay Ann Bob 10.22");
                            main.execute("2020.10.10 borrow Bob Ann 7.35");
                            main.execute("2020.10.15 repay Ann Bob 8.99");
                            main.execute("repay Bob Ann 6.46");
                            output = main.execute("2020.09.25 balance").trim();
                            if (!output.equals(NO_REPAYMENTS)) {
                                return CheckResult.wrong(INCORRECT_BALANCE);
                            }

                            output = main.execute("2020.10.30 balance open").trim();
                            words = output.split("\\s");
                            if (!isMoneyFormatted(words[words.length - 1])) {
                                return CheckResult.wrong(INCORRECT_MONEY_FORMAT);
                            }
                            if (!output.equals("Ann owes Bob 20.10")) {
                                return CheckResult.wrong(INCORRECT_BALANCE);
                            }

                            output = main.execute("2020.10.20 balance close").trim();
                            words = output.split("\\s");
                            if (!isMoneyFormatted(words[words.length - 1])) {
                                return CheckResult.wrong(INCORRECT_MONEY_FORMAT);
                            }
                            if (!output.equals("Bob owes Ann 6.46")) {
                                return CheckResult.wrong(INCORRECT_BALANCE);
                            }

                            output = main.execute("balance close").trim();
                            if (!output.equals(NO_REPAYMENTS)) {
                                return CheckResult.wrong(INCORRECT_BALANCE);
                            }

                            main.execute("exit");


                        }
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        {
                            String[] response = {"Ann owes Bob 14.00", "Chuck owes Bob 7.00", "Diana owes Bob 5.00", "Diana owes Chuck 26.00", "Elon owes Diana 12.00"};
                            TestedProgram main = new TestedProgram();
                            ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                            String output;
                            String[] lines;
                            main.start();

                            main.execute("writeOff");
                            main.execute("borrow Ann Bob 25");
                            main.execute("repay Ann Bob 15");
                            main.execute("repay Bob Chuck 7");
                            main.execute("borrow Ann Bob 4");
                            main.execute("repay Bob Diana 5");
                            main.execute("borrow Elon Diana 12");
                            main.execute("repay Chuck Diana 14");
                            main.execute("repay Chuck Diana 12");
                            output = main.execute("balance close").trim();
                            lines = output.split("\n");

                            if (lines.length < response.length) {
                                return CheckResult.wrong(INCORRECT_BALANCE);
                            }

                            for (int i = 0; i < response.length; i++) {
                                if (!lines[i].equals(response[i]) && lines[i].equals(NO_REPAYMENTS)) {
                                    return CheckResult.wrong(INCORRECT_BALANCE);
                                } else if (!lines[i].equals(response[i])) {
                                    return CheckResult.wrong("Owes should be sorted by Person who owes and Person whom owes");
                                }
                            }

                            if (!isSortedInNaturalOrder(lines)) {
                                return CheckResult.wrong("List of repayments should be sorted in a natural order.");
                            }

                            for (String line : lines) {
                                String[] words = line.split("\\s");
                                if (!isMoneyFormatted(words[words.length - 1])) {
                                    return CheckResult.wrong(INCORRECT_MONEY_FORMAT);
                                }
                            }

                            main.execute("exit");
                        }

                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        Random random = new Random();
                        List<String> persons = List.of("Annabelle", "Billibob", "Carlos", "Diana", "Elon", "Finny");
                        String keyPerson = persons.get(random.nextInt(persons.size()));
                        BigDecimal keyBalanceBorrow = BigDecimal.ZERO;
                        BigDecimal keyBalanceRepay = BigDecimal.ZERO;
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute("writeOff");
                        for (int i = 0; i < 100; i++) {
                            String personFrom = persons.get(random.nextInt(persons.size()));
                            String personTo = persons.get(random.nextInt(persons.size()));
                            if (personFrom.equalsIgnoreCase(personTo)) {
                                continue;
                            }
                            Commands command;
                            BigDecimal amount = new BigDecimal(String.format("%d.%d", random.nextInt(200), random.nextInt(99)));
                            if (random.nextBoolean()) {
                                command = Commands.borrow;
                                if (personFrom.equals(keyPerson)) {
                                    keyBalanceBorrow = keyBalanceBorrow.add(amount);
                                }
                                if (personTo.equals(keyPerson)) {
                                    keyBalanceBorrow = keyBalanceBorrow.subtract(amount);
                                }
                            } else {
                                command = Commands.repay;
                                if (personFrom.equals(keyPerson)) {
                                    keyBalanceRepay = keyBalanceRepay.add(amount);
                                }
                                if (personTo.equals(keyPerson)) {
                                    keyBalanceRepay = keyBalanceRepay.subtract(amount);
                                }
                            }
                            String line = String.format("%s %s %s %s", command, personFrom, personTo, amount);
                            main.execute(line);
                        }
                        String result = main.execute("balance close");
                        Optional<BigDecimal> sum = Arrays.stream(result.split("\n"))
                                                         .filter(it -> it.contains(keyPerson))
                                                         .map(it -> {
                                                             String[] split = it.split("\\s+");
                                                             Character sign = it.startsWith(keyPerson) ? '+' : '-';
                                                             return sign + split[split.length - 1];
                                                         })
                                                         .map(BigDecimal::new)
                                                         .reduce(BigDecimal::add);

                        BigDecimal sumBalance = keyBalanceBorrow.subtract(keyBalanceRepay);
                        if (sumBalance.compareTo(sum.orElse(BigDecimal.ZERO)) == 0) {
                            main.execute("exit");
                            return CheckResult.correct();
                        }
                        return CheckResult.wrong(WRONG_CALCULATIONS);
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        if (!main.execute("group create lowerCaseText").contains(ILLEGAL_COMMAND_ARGUMENTS)) {
                            return CheckResult.wrong(String.format(
                                    "Group name must be UPPERCASE, otherwise \"%s\" should be printed",
                                    ILLEGAL_COMMAND_ARGUMENTS));
                        }
                        if (!main.execute("group show NOTFOUNDGROUP").contains(UNKNOWN_GROUP)) {
                            return CheckResult.wrong(
                                    String.format("It should be printed \"%s\" if the group have not been created yet", UNKNOWN_GROUP));
                        }

                        main.execute("group create BOYS (Elon, Bob, Chuck)");
                        String showGroupResult = main.execute("group show BOYS").trim();
                        if (!equalsByLines(showGroupResult, """
                            Bob
                            Chuck
                            Elon""")) {
                            return CheckResult.wrong(GROUP_PERSONS_FEEDBACK);
                        }
                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute("writeOff");
                        main.execute("group create COFFEETEAM (Ann, Bob)");
                        main.execute("purchase Bob coffee 10 (COFFEETEAM)");
                        String balanceFirst = main.execute("balance close").trim();
                        if (balanceFirst.contains("Bob owes")) {
                            return CheckResult.wrong("Only Ann owes Bob. Bob should not owe to himself");
                        }
                        if (!balanceFirst.equals("Ann owes Bob 5.00")) {
                            return CheckResult.wrong(INCORRECT_BALANCE);
                        }
                        main.execute("repay Ann Bob 5.00");
                        String balanceSecond = main.execute("balance close").trim();
                        if (!balanceSecond.equals(NO_REPAYMENTS)) {
                            return CheckResult.wrong(
                                    "If everybody owes zero, it should be printed \"No repayments\"");
                        }
                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute("writeOff");
                        main.execute("group create FRIENDS (Ann, Bob, Chuck)");
                        main.execute("purchase Elon chocolate 12.50 (FRIENDS)");
                        String balanceResult = main.execute("balance close");
                        if (!equalsByLines(balanceResult, """
                            Ann owes Elon 4.17
                            Bob owes Elon 4.17
                            Chuck owes Elon 4.16""")) {
                            return CheckResult.wrong("The remainder after division should be spread amongst the first N persons sorted in natural order just like the examples");
                        }
                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute("writeOff");
                        main.execute("group create BOYS (Elon, Bob, Chuck)");
                        main.execute("group create GIRLS (Ann, Diana)");
                        main.execute("2020.10.20 purchase Diana flowers 15.65 (BOYS)");
                        main.execute("2020.10.21 purchase Chuck chocolate 6.30 (BOYS)");
                        main.execute("2020.10.22 purchase Bob icecream 3.99 (GIRLS)");
                        String balanceCloseResult = main.execute("balance close");
                        if (!equalsByLines(balanceCloseResult, """
                            Ann owes Bob 2.00
                            Bob owes Chuck 2.10
                            Bob owes Diana 3.23
                            Chuck owes Diana 5.22
                            Elon owes Chuck 2.10
                            Elon owes Diana 5.21""")) {
                            return CheckResult.wrong("Output should be the same as in example");
                        }

                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute("group create GIRLS (Ann, Diana)");
                        main.execute("group create TEAM (+Bob, GIRLS, -Frank, Chuck)");
                        String groupResult = main.execute("group show TEAM");
                        if (!equalsByLines(groupResult, """
                            Ann
                            Bob
                            Chuck
                            Diana""")) {
                            return CheckResult.wrong("Program should include Bob, Chuck and persons from GIRLS, also Frank should be excluded");
                        }

                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute("writeOff");
                        main.execute("group create GIRLS (Ann, Diana)");
                        main.execute("group create TEAM (+Bob, GIRLS, -Frank, Chuck)");
                        main.execute("2020.10.20 purchase Diana flowers 15.65 (TEAM, Elon, -GIRLS)");
                        main.execute("2020.10.21 purchase Elon ChuckBirthdayGift 20.99 (TEAM, -Chuck)");
                        String balanceResult = main.execute("balance close").trim();

                        if (!isSortedInNaturalOrder(balanceResult.split("\n"))) {
                            return CheckResult.wrong("List of repayments should be sorted in a natural order.");
                        }

                        if (balanceResult.contains("Ann owes Diana")) {
                            return CheckResult.wrong("Program should split flowers bill on TEAM with Elon without GIRLS");
                        }

                        if (balanceResult.contains("Chuck owes Elon")) {
                            return CheckResult.wrong("Program should split ChuckBirthdayGift bill on TEAM without Chuck");
                        }

                        if (balanceResult.contains("Elon owes Diana")) {
                            return CheckResult.wrong("Wrong calculations. Elon initially owes Diana for " +
                                                             "the flower purchase but remember Elon purchases " +
                                                             "ChuckBirthdayGift which covers the cost, plus extra");
                        }

                        if (!equalsByLines(balanceResult, """
                            Ann owes Elon 7.00
                            Bob owes Diana 5.22
                            Bob owes Elon 7.00
                            Chuck owes Diana 5.22
                            Diana owes Elon 1.78""")) {
                            return CheckResult.wrong(INCORRECT_BALANCE);
                        }

                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        String output;
                        main.start();
                        main.execute("writeOff");
                        main.execute("group create SOMEGROUP (Bob, -Bob)");
                        output = main.execute("group show SOMEGROUP").toLowerCase();
                        if (!output.contains("empty")) {
                            return CheckResult.wrong(EMPTY_GROUP);
                        }

                        main.execute("group add SOMEGROUP (Bob)");
                        main.execute("group remove SOMEGROUP (Bob)");
                        output = main.execute("group show SOMEGROUP").toLowerCase();
                        if (!output.contains("empty")) {
                            return CheckResult.wrong(EMPTY_GROUP);
                        }

                        main.execute("group create ANOTHERGROUP (SOMEGROUP)");
                        output = main.execute("group show ANOTHERGROUP").toLowerCase();
                        if (!output.contains("empty")) {
                            return CheckResult.wrong(EMPTY_GROUP);
                        }

                        output = main.execute("2020.10.21 purchase Elon chocolate 6.30 (SOMEGROUP)").toLowerCase();
                        if (!output.contains("group is empty")) {
                            return CheckResult.wrong(EMPTY_GROUP);
                        }

                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute("group create SOMEGROUP (Bob)");
                        main.execute("group create GIRLS (Ann, Diana)");
                        main.execute("group create BOYS (Bob, Chuck, Elon)");
                        main.execute("group add SOMEGROUP (GIRLS, Frank)");
                        main.execute("group remove SOMEGROUP (-BOYS, Bob, +Frank)");
                        String groupResult = main.execute("group show SOMEGROUP");
                        if (!equalsByLines(groupResult, """
                            Ann
                            Bob
                            Diana""")) {
                            return CheckResult.wrong("First of all program should collect persons from brackets:" +
                                 "At first collect all additions, and then remove all persons to delete." +
                                 "eg. group <some group command> GROUP (-BOYS, Bob, +Frank): " +
                                 "program should collect Bob and Frank" +
                                 "and then remove all persons from BOYS");
                        }
                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        List<String> persons = List.of("Gordon", "Bob", "Ann", "Chuck", "Elon", "Diana", "Foxy");

                        AtomicInteger counter = new AtomicInteger(0);
                        Map<String, Integer> map = persons.stream().sorted()
                                                          .collect(Collectors.toMap(it -> it, it -> counter.getAndIncrement(),
                                                                                    (a, b) -> {
                                                                                        throw new UnsupportedOperationException();
                                                                                    },
                                                                                    LinkedHashMap::new));

                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute(String.format("group create SOMESANTAGROUP (%s)", String.join(",", persons)));
                        String secretSantaResult = main.execute("secretSanta SOMESANTAGROUP");

                        if (!secretSantaResult.lines().allMatch(it -> it.contains(GIFT_TO))) {
                            return CheckResult.wrong("Each line should contains \" gift to \"");
                        }
                        List<Integer> sendersList = new ArrayList<>();
                        List<Integer> receiversList = new ArrayList<>();
                        secretSantaResult.lines().map(String::trim)
                                         .map(it -> it.split(GIFT_TO))
                                         .forEach(it -> {
                                             sendersList.add(map.get(it[0]));
                                             receiversList.add(map.get(it[1]));
                                         });
                        if (sendersList.size() != persons.size() || !isSorted(sendersList)) {
                            return CheckResult.wrong("Program should print persons who will gift to someone in ascending order");
                        }
                        for (int i = 0; i < sendersList.size(); i++) {
                            if (sendersList.get(i).equals(receiversList.get(i)) && sendersList.size() > 1) {
                                return CheckResult.wrong("Person should not gift a present to himself (in groups larger than 1)");
                            }
                            Integer receiverId = receiversList.get(i);
                            if (sendersList.get(receiverId) == i && sendersList.size() > 2) {
                                return CheckResult.wrong("Person should not gift and receive a present from the same other person (in groups larger than 2)");
                            }
                        }
                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute("writeOff");
                        main.execute("group create TEAM (Bob, Ann, Frank, Chuck, Elon, Diana)");
                        main.execute("2020.12.25 cashBack YourCompany secretSantaGift 24.00 (TEAM)");
                        String balanceResult = main.execute("2020.12.25 balance close");
                        if (!equalsByLines(balanceResult, """
                            YourCompany owes Ann 4.00
                            YourCompany owes Bob 4.00
                            YourCompany owes Chuck 4.00
                            YourCompany owes Diana 4.00
                            YourCompany owes Elon 4.00
                            YourCompany owes Frank 4.00""")) {
                            return CheckResult.wrong("Program should output list of YourCompany owes to everyone in TEAM");
                        }
                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        strToLinesTrimmed("""
                            writeOff
                            group create TEAM (Ann, Bob, Chuck, Diana, Elon, Frank)
                            group create CAR (Diana, Elon)
                            group create BUS (Ann, Bob, Chuck, Frank)
                            purchase Chuck busTickets 5.25 (BUS, -Frank)
                            purchase Elon fuel 25 (CAR, Frank)
                            purchase Ann chocolate 2.99 (BUS, -Bob, CAR)
                            purchase Diana soda 5.45 (TEAM, -Ann, -Chuck)
                            purchase Frank bbq 29.90 (TEAM, CAR, BUS, -Frank, -Bob)
                            cashBack YourCompany party 12 (TEAM, BUS)
                            cashBack YourCompany tickets 3.50 (BUS)
                            borrow Frank Bob 10
                            repay Chuck Diana 20""")
                                .forEach(main::execute);
                        String balanceResult = main.execute("balance close");
                        if (!equalsByLines(balanceResult, """
                            Ann owes Chuck 1.15
                            Ann owes Frank 6.89
                            Bob owes Chuck 1.75
                            Bob owes Diana 1.37
                            Chuck owes Frank 7.48
                            Diana owes Ann 0.60
                            Diana owes Chuck 20.00
                            Diana owes Elon 6.98
                            Diana owes Frank 6.11
                            Elon owes Ann 0.60
                            Frank owes Bob 10.00
                            Frank owes Elon 0.86
                            YourCompany owes Ann 2.88
                            YourCompany owes Bob 2.88
                            YourCompany owes Chuck 2.87
                            YourCompany owes Diana 2.00
                            YourCompany owes Elon 2.00
                            YourCompany owes Frank 2.87""")) {
                            return CheckResult.wrong(WRONG_CALCULATIONS);
                        }
                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute("writeOff");
                        main.execute("group create BOBTEAM (Frank, Bob)");
                        main.execute("purchase Ann coffee 12.00 (Chuck, Ann, Bob)");
                        {
                            String balanceResult = main.execute("balance close (Bob, Ann)");
                            if (!equalsByLines(balanceResult, "Bob owes Ann 4.00")) {
                                return CheckResult.wrong(FILTERED_BALANCE_FEEDBACK);
                            }
                        }
                        {
                            String balanceResult = main.execute("balance close (-Bob, BOBTEAM)");
                            if (!equalsByLines(balanceResult, NO_REPAYMENTS)) {
                                return CheckResult.wrong(String.format("Program should output \"%s\" if no one person in filter have owes", NO_REPAYMENTS));
                            }
                        }
                        {
                            String balanceResult = main.execute("balance close (AGROUP)").trim().toLowerCase();
                            if (!balanceResult.contains("group is empty")) {
                                return CheckResult.wrong("Program should output \"Group is empty\" if the balance command is entered on an empty group");
                            }
                        }
                        {
                            String balanceResult = main.execute("balance close (GROUPIDIDNOTCREATE)").trim().toLowerCase();
                            if (!balanceResult.contains("not exist")) {
                                return CheckResult.wrong("Program should output \"Group does not exist\" if the balance command is entered on a group that has not been created.");
                            }
                        }
                        main.execute("exit");
                        return CheckResult.correct();
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        strToLinesTrimmed("""
                            writeOff
                            borrow Bob Chuck 100
                            borrow Chuck Diana 100
                            borrow Chuck Bob 30
                            borrow Diana Bob 100""")
                                .forEach(main::execute);
                        String balancePerfectResult = main.execute("balancePerfect close");
                        if (getLinesCount(balancePerfectResult) >= 3) {
                            return CheckResult.wrong(BALANCE_PERFECT_FEEDBACK);
                        }
                        if (equalsByLines(balancePerfectResult, "Chuck owes Bob 30.00") ||
                                equalsByLines(balancePerfectResult, "" +
                                        "Chuck owes Diana 30.00\n" +
                                        "Diana owes Bob 30.00")) {
                            main.execute("exit");
                            return CheckResult.correct();
                        }
                        return CheckResult.wrong(BALANCE_PERFECT_FEEDBACK);
                    }),

                    new TestCase<String>().setDynamicTesting(() -> {
                        Random random = new Random();
                        Random RANDOM_DETERM = new Random(42);
                        List<String> persons = List.of("Andy", "Bobby", "Claire", "Diana", "Eagle", "Forb");
                        String keyPerson = persons.get(random.nextInt(persons.size()));
                        BigDecimal keyBalanceBorrow = BigDecimal.ZERO;
                        BigDecimal keyBalanceRepay = BigDecimal.ZERO;
                        TestedProgram main = new TestedProgram();
                        ((MainMethodExecutor) main.getProgramExecutor()).setUseSeparateClassLoader(false);
                        main.start();
                        main.execute("writeOff");
                        for (int i = 0; i < 100; i++) {
                            String personFrom = persons.get(RANDOM_DETERM.nextInt(persons.size()));
                            String personTo = persons.get(RANDOM_DETERM.nextInt(persons.size()));
                            if (personFrom.equalsIgnoreCase(personTo)) {
                                continue;
                            }
                            Commands command;
                            BigDecimal amount = new BigDecimal(String.format("%d.%d", RANDOM_DETERM.nextInt(200), random.nextInt(99)));
                            if (RANDOM_DETERM.nextBoolean()) {
                                command = Commands.borrow;
                                if (personFrom.equals(keyPerson)) {
                                    keyBalanceBorrow = keyBalanceBorrow.add(amount);
                                }
                                if (personTo.equals(keyPerson)) {
                                    keyBalanceBorrow = keyBalanceBorrow.subtract(amount);
                                }
                            } else {
                                command = Commands.repay;
                                if (personFrom.equals(keyPerson)) {
                                    keyBalanceRepay = keyBalanceRepay.add(amount);
                                }
                                if (personTo.equals(keyPerson)) {
                                    keyBalanceRepay = keyBalanceRepay.subtract(amount);
                                }
                            }
                            String line = String.format("%s %s %s %s", command, personFrom, personTo, amount);
                            main.execute(line);
                        }
                        String balanceResult = main.execute("balance close");
                        boolean isOkBalance = isBalanceResultOk(keyPerson, balanceResult, keyBalanceBorrow.subtract(keyBalanceRepay));
                        if (!isOkBalance) {
                            return CheckResult.wrong("Command balance: " + WRONG_CALCULATIONS);
                        }
                        String balancePerfectResult = main.execute("balancePerfect close");
                        boolean isOkBalancePerfect = isBalanceResultOk(keyPerson, balancePerfectResult, keyBalanceBorrow.subtract(keyBalanceRepay));
                        if (!isOkBalancePerfect) {
                            return CheckResult.wrong("Command balancePerfect: " + WRONG_CALCULATIONS);
                        }
                        if (getLinesCount(balancePerfectResult) >= getLinesCount(balanceResult)) {
                            return CheckResult.wrong(BALANCE_PERFECT_FEEDBACK);
                        }
                        main.execute("exit");
                        return CheckResult.correct();
                    })


            );
        }

        private boolean isMoneyFormatted(String s) {

            return s.matches("\\d+.\\d+");
        }

        private boolean isSortedInNaturalOrder(String[] arr) {

            String previous = "";

            for (String current : arr) {
                if (current.compareTo(previous) < 0) {
                    return false;
                }
                previous = current;
            }
            return true;
        }

        private <T extends Comparable<T>> boolean isSorted(List<T> list) {

            ArrayList<T> sorted = new ArrayList<>(list);
            return sorted.equals(list);
        }

        private CheckResult checkHelpCommand(String reply, String attach) {

            String[] replyArr = reply.split("\n");
            List<String> commandList = getCommandList();
            if (replyArr.length != commandList.size()) {
                return CheckResult.wrong(HELP_ERROR);
            }
            for (int i = 0; i < replyArr.length; i++) {
                if (!replyArr[i].toLowerCase().startsWith(commandList.get(i).toLowerCase())) {
                    return CheckResult.wrong(HELP_ERROR);
                }
            }
            return CheckResult.correct();
        }

        private CheckResult checkUnknownCommand(String reply, String attach) {

            try {
                reply = reply.trim();
                Commands command = Commands.valueOf(reply);
            } catch (IllegalArgumentException e) {
                if (!reply.toLowerCase().startsWith(UNKNOWN_COMMAND.toLowerCase())) {
                    return CheckResult.wrong(String.format("For unknown command output should starts with: %s", UNKNOWN_COMMAND));
                }
            }
            return CheckResult.correct();
        }

        private List<String> getCommandList() {

            return Arrays.stream(Commands.values())
                         .map(Enum::toString)
                         .sorted().collect(Collectors.toList());
        }

        private String concatLines(List<String> strings) {

            return String.join("\n", strings);
        }

        private String concatLines(String... strings) {

            return String.join("\n", strings);
        }

        enum Commands {
            help,
            borrow,
            repay,
            balance,
            exit,
            group,
            purchase,
            secretSanta,
            cashBack,
            writeOff,
            balancePerfect
        }
    }
  learner_created: false
- name: src/splitter/util/DateUtil.java
  visible: true
  text: |
    package splitter.util;

    import java.time.LocalDate;
    import java.time.format.DateTimeFormatter;
    import java.util.Optional;
    import java.util.regex.Pattern;

    public class DateUtil {

        private static final Pattern DATE_PATTERN = Pattern.compile("\\d{4}\\.\\d{2}\\.\\d{2}");

        private static final DateTimeFormatter FORMATTER = DateTimeFormatter.ofPattern("yyyy.MM.dd");

        public static LocalDate getDate(String input) {
            return Optional.of(input)
                    .filter(DATE_PATTERN.asPredicate())
                    .map(it -> LocalDate.parse(it, FORMATTER))
                    .orElse(LocalDate.now());
        }

        public static boolean isDate(String date) {
            return DATE_PATTERN.matcher(date).matches();
        }
    }
  learner_created: true
- name: src/splitter/entity/Members.java
  visible: true
  text: |
    package splitter.entity;

    import javax.persistence.*;
    import java.util.HashSet;
    import java.util.Set;

    @Entity
    @Table(name = "Members")
    public class Members {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = "member_id")
        private Long memberId;

        @Column(name = "member_name", unique = true)
        private String memberName;

        @ManyToMany(mappedBy = "members")
        private Set<Groups> groups = new HashSet<>();

        public Members() {}

        public Members(String memberName) {
            this.memberName = memberName;
        }

        public Set<Groups> getGroups() { // получишь набор групп, в которых состоит member
            return groups;
        }

        public String getMemberName() {
            return memberName;
        }

        public void setMemberName(String name) {
        }
    }
  learner_created: true
- name: src/splitter/parser/GroupParser.java
  visible: true
  text: |+
    package splitter.parser;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Component;
    import splitter.Command;
    import splitter.CommandProcessor;
    import splitter.entity.Members;
    import splitter.service.GroupService;
    import splitter.util.RegexPatterns;

    import java.util.*;
    import java.util.function.Consumer;
    import java.util.regex.*;
    import java.util.stream.*;

    @Component
    public class GroupParser implements CommandProcessor {

        private final GroupService groupService;

        @Autowired
        public GroupParser(GroupService groupService) {
            this.groupService = groupService;
        }

        @Override
        public List<Command> getCommand() {
            return Collections.singletonList(Command.group);
        }

        @Override
        public void process(List<String> input) {
            try {
                String command = input.get(1);
                String groupName = RegexPatterns.GROUP_PATTERN.matcher(input.get(2))
                        .results()
                        .reduce((first, second) -> second)
                        .map(MatchResult::group)
                        .orElseThrow(() -> new IllegalArgumentException("Illegal command arguments"));
                Set<String> membersSet = new HashSet<>();
                process(input, RegexPatterns.PLUS_PATTERN, membersSet::addAll);
                process(input, RegexPatterns.MINUS_PATTERN, membersSet::removeAll);
                switch (command) {
                    case "create" -> groupService.createGroup(groupName, membersSet);
                    case "add" -> groupService.updateGroup(groupName, membersSet);
                    case "remove" -> groupService.removeFromGroup(groupName, membersSet);
                    case "show" -> groupService.showGroup(groupName);
                    default -> throw new IllegalArgumentException();
                }
            } catch (Exception e) {
                System.out.println("Illegal command arguments");
            }
        }

        private void process(List<String> input, Pattern PATTERN, Consumer<List<String>> action) {
            Map<Boolean, List<String>> map = input.stream()
                    .skip(3)
                    .flatMap(it -> PATTERN.matcher(it).results())
                    .map(MatchResult::group)
                    .collect(Collectors.partitioningBy(it -> RegexPatterns.GROUP_PATTERN.matcher(it).matches()));


            List<String> groupList = map.getOrDefault(true, Collections.emptyList()); // it's a group name
            List<String> names = map.getOrDefault(false, Collections.emptyList()); // it's a members name

            List<String> finalNames = new ArrayList<>();
            finalNames.addAll(names);
            finalNames.addAll(groupService.ungroupNames(groupList));

            action.accept(finalNames);
        }
    }

  learner_created: true
- name: src/splitter/util/RegexPatterns.java
  visible: true
  text: |
    package splitter.util;

    import java.util.regex.Pattern;

    public class RegexPatterns {

        public static final Pattern PLUS_PATTERN = Pattern.compile("(?:(?<=\\+)|(?<![-\\w]))[A-Z]+(?!\\w)", Pattern.CASE_INSENSITIVE);
        public static final Pattern MINUS_PATTERN = Pattern.compile("(?:(?<=\\-))[A-Z]+(?!\\w)", Pattern.CASE_INSENSITIVE);
        public static final Pattern GROUP_PATTERN = Pattern.compile("[A-Z]+\\b");
    }
  learner_created: true
- name: src/splitter/entity/Groups.java
  visible: true
  text: |+
    package splitter.entity;

    import javax.persistence.*;
    import java.util.*;

    @Entity
    public class Groups {
        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = "group_id")
        private Long groupId;

        @Column(name = "group_name", unique = true)
        private String groupName;

        @ManyToMany
        @JoinTable(
                name = "group_members",
                joinColumns = @JoinColumn(name = "group_id"),
                inverseJoinColumns = @JoinColumn(name = "member_id"))
        private final Set<Members> members = new HashSet<>();

        public Groups() {}

        public Groups(String groupName) {
            this.groupName = groupName;
        }

        public Set<Members> getMembers() {
            return members;
        }

        public Long getGroupId() {
            return groupId;
        }

        public String getGroupName() {
            return groupName;
        }

        public void setMembers(Set<Members> members) {
            if (members != null) {
                this.members.clear();
                this.members.addAll(members);
            }
        }

        public void setGroupId(Long groupId) {
            this.groupId = groupId;
        }

        public void setGroupName(String groupName) {
            this.groupName = groupName;
        }
    }

  learner_created: true
- name: src/splitter/AmountCalculator.java
  visible: true
  text: |
    package splitter;

    import java.math.BigDecimal;
    import java.math.RoundingMode;
    import java.util.*;
    import java.util.stream.Collectors;
    import java.util.stream.IntStream;

    public class AmountCalculator {

        private final BigDecimal minimumAmount;
        private final BigDecimal totalPrice;
        private final Set<String> temporary;
        private final String payerPerson;

        public AmountCalculator(BigDecimal totalPrice, Set<String> temporary, String payerPerson) {
            this.minimumAmount = new BigDecimal("0.01");
            this.totalPrice = totalPrice;
            this.temporary = new LinkedHashSet<>(temporary);
            this.payerPerson = payerPerson;
        }

        public BigDecimal calcSharedAmount(BigDecimal quantityPerson) {
            return totalPrice.divide(quantityPerson,2, RoundingMode.DOWN);
        }

        public boolean hasRemainder(BigDecimal sharedAmount, BigDecimal quantityPerson) {
            return !totalPrice.equals(sharedAmount.multiply(quantityPerson)); //true
        }

        public Deque<String> calcExtraPayers(boolean haveRemainder, BigDecimal sharedAmount, BigDecimal quantityPerson) {
            BigDecimal remainderAmount = haveRemainder ? totalPrice.subtract(sharedAmount.multiply(quantityPerson)) : BigDecimal.ZERO; //0.02
            int extraPayersCount = haveRemainder ? remainderAmount.divide(minimumAmount, RoundingMode.DOWN).intValue() : 0; // 2

    //        System.out.println("remainderAmount " + remainderAmount);
    //        System.out.println("extraPayersCount " + extraPayersCount);

            List<String> temporaryList = new ArrayList<>(temporary);

            return IntStream.range(0, extraPayersCount)
                    .mapToObj(temporaryList::get)
                    .collect(Collectors.toCollection(LinkedList::new));
        }

        public BigDecimal getMinimumAmount() {
            return minimumAmount;
        }
    }
  learner_created: true
- name: build.gradle
  visible: true
  text: |-
    buildscript {
        apply plugin: 'hyperskill'

        repositories {
            mavenCentral()
        }
        dependencies {
            classpath "org.springframework.boot:spring-boot-gradle-plugin:$hs.spring.bootVersion"
            classpath "io.spring.gradle:dependency-management-plugin:$hs.spring.dependencyManagementVersion"
        }
    }

    apply plugin: 'java'
    apply plugin: 'org.springframework.boot'
    apply plugin: 'io.spring.dependency-management'

    repositories {
        mavenCentral()
    }

    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter'
        implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
        implementation 'org.springframework.boot:spring-boot-starter-web'

        runtimeOnly 'com.h2database:h2'
    }
  learner_created: true
- name: src/splitter/service/BalanceService.java
  visible: true
  text: |
    package splitter.service;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    import splitter.BalanceType;
    import splitter.entity.Balance;
    import splitter.entity.Members;
    import splitter.repository.BalanceRepository;

    import java.math.*;
    import java.time.LocalDate;
    import java.util.*;
    import java.util.stream.Collectors;

    @Service
    public class BalanceService {

        private static final String KEY_DELIMITER = "-";

        private final BalanceRepository balanceRepository;

        @Autowired
        public BalanceService(BalanceRepository balanceRepository) {
            this.balanceRepository = balanceRepository;
        }

        @Transactional
        public void process(LocalDate date, BalanceType balanceType, Set<String> temporary) {
            List<Balance> balances = balanceRepository.findAll();

            if (!balances.isEmpty()) {
                Set<String> processedMembers = new HashSet<>();
                List<String> results = new ArrayList<>();

                for (Balance balance : balances) {
                    var fromMember = balance.getFromMember();
                    var toMember = balance.getToMember();

                    String[] name = new String[]{fromMember.getMemberName(), toMember.getMemberName()};
                    String memberKey = fromMember.getMemberName() + KEY_DELIMITER + toMember.getMemberName();
                    if (processedMembers.contains(memberKey)) {
                        continue;
                    }
                    //filter all balances records to find all records that match the current member pair (fromMember and toMember).
                    List<Balance> memberKeyBalance = balances.stream()
                            .filter(it -> it.getFromMember().equals(fromMember) && it.getToMember().equals(toMember)).toList();
                    final LocalDate finalDate = (balanceType == BalanceType.open) ? date.withDayOfMonth(1) : date;

                    BigDecimal totalAmount = memberKeyBalance.stream()
                            .filter(it -> checkIsBalanceFromHistory(finalDate, it.getDate(), balanceType))
                            .sorted(Comparator.comparing(Balance::getDate))
                            .reduce((first, second) -> second)
                            .map(Balance::getAmount)
                            .orElse(BigDecimal.ZERO);
                    results.add((totalAmount.signum() == 0) ? "No repayments" : buildRepaymentString(name, totalAmount));
                    processedMembers.add(memberKey);
                }
                filterPrintResults(results, temporary);
            } else {
                System.out.println("No repayments");
            }
        }

        private void filterPrintResults(List<String> results, Set<String> temporary) {
            if (!temporary.isEmpty()) {
                results = results.stream()
                        .filter(it -> {
                            String ownMember = it.split(" ")[0];
                            return temporary.contains(ownMember);
                        })
                        .collect(Collectors.toList());
                if (results.isEmpty()) {
                    System.out.println("No repayments");
                }
            }
            results.stream().sorted().forEach(System.out::println);
        }

        private static String buildRepaymentString(String[] name, BigDecimal totalAmount) {
            BigDecimal resultTotalAmount = totalAmount.setScale(2, RoundingMode.HALF_EVEN);
            boolean negate = totalAmount.signum() == -1;
            if (negate) {
                resultTotalAmount = resultTotalAmount.negate();
            }

            var first = negate ? name[1] : name[0];
            var second = negate ? name[0] : name[1];

            return String.format("%s owes %s %s", first, second, resultTotalAmount);
        }

        private boolean checkIsBalanceFromHistory(LocalDate date, LocalDate balanceDate, BalanceType balanceType) {
            return balanceType == BalanceType.close && !balanceDate.isAfter(date)
                    || balanceType == BalanceType.open && balanceDate.isBefore(date);
        }

        public BigDecimal getCurrentAmount(Members mainPerson, Members secondPerson) {
            return balanceRepository.findCurrentAmount(mainPerson, secondPerson)
                    .stream()
                    .findFirst()
                    .orElse(BigDecimal.ZERO);
        }
    }
  learner_created: true
- name: src/splitter/service/BorrowRepayService.java
  visible: true
  text: |
    package splitter.service;

    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    import splitter.util.NameKey;
    import splitter.Command;
    import splitter.entity.Balance;
    import splitter.entity.Members;
    import splitter.entity.Transactions;
    import splitter.repository.*;

    import java.math.*;
    import java.time.LocalDate;
    import java.util.List;
    import java.util.Optional;

    @Service
    public class BorrowRepayService {

        private final MembersRepository membersRepository;
        private final BalanceRepository balanceRepository;
        private final TransactionsRepository transactionsRepository;
        private final BalanceService balanceService;

        public BorrowRepayService(MembersRepository membersRepository, BalanceRepository balanceRepository, TransactionsRepository transactionsRepository, BalanceService balanceService) {
            this.membersRepository = membersRepository;
            this.balanceRepository = balanceRepository;
            this.transactionsRepository = transactionsRepository;
            this.balanceService = balanceService;
        }

        @Transactional
        public void process(LocalDate date, Command command, BigDecimal amount, String person1, String person2) {
            Optional<Members> memberFirst = membersRepository.findByMemberName(person1);
            Optional<Members> memberSecond = membersRepository.findByMemberName(person2);

            Members personOne = memberFirst.orElseGet(() -> membersRepository.save(new Members(person1)));
            Members personTwo = memberSecond.orElseGet(() -> membersRepository.save(new Members(person2)));

            boolean keyEquals = NameKey.isKeyEquals(person1, person2);
            var mainPerson = keyEquals ? personOne : personTwo;
            var secondPerson = keyEquals ? personTwo : personOne;

            BigDecimal currentAmount = balanceService.getCurrentAmount(mainPerson, secondPerson);
            BigDecimal newAmount = calculateNewAmount(command, amount, currentAmount, keyEquals);

            balanceRepository.save(new Balance(mainPerson, secondPerson, date, newAmount));
            transactionsRepository.save(new Transactions(command.name(), date, personOne, personTwo, amount));
        }

        private BigDecimal calculateNewAmount(Command command, BigDecimal amount, BigDecimal currentAmount, boolean keyEquals) {
            return switch (command) {
                case borrow -> keyEquals ? currentAmount.add(amount) : currentAmount.subtract(amount);
                case repay -> keyEquals ? currentAmount.subtract(amount) : currentAmount.add(amount);
                default -> null;
            };
        }
    }
  learner_created: true
- name: src/splitter/BalanceType.java
  visible: true
  text: |
    package splitter;

    public enum BalanceType {
        open,
        close
    }
  learner_created: true
- name: src/splitter/Command.java
  visible: true
  text: |
    package splitter;

    public enum Command {
        balance,
        borrow,
        cashBack,
        exit,
        group,
        help,
        purchase,
        repay,
        secretSanta,
        writeOff;

        public static Command of(String value) {
            for (Command command : Command.values()) {
                if (value.contains(command.name())) {
                    return command;
                }
            }
            return null;
        }
    }
  learner_created: true
- name: src/splitter/parser/BalanceParser.java
  visible: true
  text: |
    package splitter.parser;

    import org.springframework.stereotype.Component;
    import splitter.BalanceType;
    import splitter.Command;
    import splitter.CommandProcessor;
    import splitter.service.BalanceService;
    import splitter.service.GroupService;
    import splitter.util.DateUtil;
    import splitter.util.RegexPatterns;

    import java.time.LocalDate;
    import java.util.*;
    import java.util.function.Consumer;
    import java.util.regex.MatchResult;
    import java.util.regex.Pattern;
    import java.util.stream.Collectors;

    @Component
    public class BalanceParser implements CommandProcessor {

        private BalanceType balanceType = BalanceType.close;
        private final BalanceService balanceService;
        private final GroupService groupService;

        public BalanceParser(BalanceService balanceService, GroupService groupService) {
            this.balanceService = balanceService;
            this.groupService = groupService;
        }

        @Override
        public List<Command> getCommand() {
            return Collections.singletonList(Command.balance);
        }

        @Override
        public void process(List<String> input) {
            try {
                LocalDate date = LocalDate.now();
                int commandIndex = 0;

                if (DateUtil.isDate(input.get(0))) {
                    date = DateUtil.getDate(input.get(0));
                    commandIndex = 1;
                }

                if (input.size() > commandIndex + 1) {
                    Optional.ofNullable(input.get(commandIndex + 1))
                            .filter(it -> Arrays.stream(BalanceType.values())
                                    .anyMatch(balanceType -> balanceType.name().equals(it)))
                            .map(BalanceType::valueOf)
                            .ifPresent(it -> balanceType = it);
                }
                Set<String> temporary = new TreeSet<>();
                process(input, commandIndex, RegexPatterns.PLUS_PATTERN, temporary::addAll);
                process(input, commandIndex, RegexPatterns.MINUS_PATTERN, temporary::removeAll);

                balanceService.process(date, balanceType, temporary);
            } catch (Exception e) {
                System.out.println("Illegal command arguments");
            }
        }
        private void process(List<String> input, int index, Pattern PATTERN, Consumer<List<String>> action) {
            Map<Boolean, List<String>> map = input.stream()
                    .skip(index + 2)
                    .flatMap(it -> PATTERN.matcher(it).results())
                    .map(MatchResult::group)
                    .collect(Collectors.partitioningBy(it -> RegexPatterns.GROUP_PATTERN.matcher(it).matches()));

            List<String> gropList = map.getOrDefault(true, Collections.emptyList());
            Set<String> namesFromGroup = groupService.ungroupNames(gropList);

            List<String> names = map.getOrDefault(false, Collections.emptyList());
            List<String> finalNames = new ArrayList<>();
            finalNames.addAll(names);
            finalNames.addAll(namesFromGroup);
            action.accept(finalNames);
        }
    }
  learner_created: true
- name: src/resources/application.properties
  visible: true
  text: |+
    spring.main.banner-mode=off
    spring.main.web-application-type=NONE
    logging.level.root=error

    #spring.jpa.properties.hibernate.hbm2ddl.auto=create

    # URL database connections
    spring.datasource.url=jdbc:h2:file:./testDB.mv.db

    # Driver JDBC
    spring.datasource.driver-class-name=org.h2.Driver

    # User and password
    spring.datasource.username=admin
    spring.datasource.password=12345

    # To automatically update the database schema
    spring.jpa.hibernate.ddl-auto=update

    # Enabling H2 console for database management via browser
    spring.h2.console.enabled=true

    #spring.jpa.database-platform=org.hibernate.dialect.H2Dialect
    #spring.h2.console.settings.trace=true

  learner_created: true
- name: src/splitter/service/SecretSanta.java
  visible: true
  text: |
    package splitter.service;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    import splitter.Command;
    import splitter.CommandProcessor;
    import splitter.entity.Groups;
    import splitter.entity.Members;
    import splitter.repository.GroupsRepository;

    import java.util.*;

    @Service
    public class SecretSanta implements CommandProcessor {

        private final GroupsRepository groupsRepository;

        @Autowired
        public SecretSanta(GroupsRepository groupsRepository) {
            this.groupsRepository = groupsRepository;
        }


        @Override
        @Transactional
        public void process(List<String> input) {
            String groupName = input.get(1);
            Optional<Groups> existingGroup = groupsRepository.findByGroupName(groupName);
            if (existingGroup.isPresent()) {
                Groups group = existingGroup.get();
                Set<Members> membersSet = group.getMembers();
                List<Members> members = new ArrayList<>(membersSet);
                List<Members> shuffledMembers = shuffleMembers(members);
                for (int i = 0; i < members.size(); i++) {
                    System.out.println(members.get(i).getMemberName() + " gift to " + shuffledMembers.get(i).getMemberName());
                }
            }
        }

        private List<Members> shuffleMembers(List<Members> members) {
            List<Members> shuffleMembers = new ArrayList<>(members);
            Random random = new Random(System.currentTimeMillis());
            do {
                Collections.shuffle(shuffleMembers, random);
            } while (!isShuffleValid(members, shuffleMembers));

            return shuffleMembers;
        }

        private boolean isShuffleValid(List<Members> members, List<Members> shuffled) {
            Map<Members, Members> giftPairs = new HashMap<>();
            for (int i = 0; i < members.size(); i++) {
                if (members.get(i).equals(shuffled.get(i))) {
                    return false;
                }
                giftPairs.put(members.get(i), shuffled.get(i));
            }
            if (members.size() > 2) {
                for (Map.Entry<Members, Members> entry : giftPairs.entrySet()) {
                    Members giver = entry.getKey();
                    Members receiver = entry.getValue();

                    if (giftPairs.get(receiver) != null && giftPairs.get(receiver).equals(giver)) {
                        return false;
                    }
                }
            }
            return true;
        }

        @Override
        public List<Command> getCommand() {
            return Collections.singletonList(Command.secretSanta);
        }
    }
  learner_created: true
- name: src/splitter/repository/MembersRepository.java
  visible: true
  text: |
    package splitter.repository;

    import org.springframework.data.jpa.repository.JpaRepository;
    import splitter.entity.Members;

    import java.util.Optional;

    public interface MembersRepository extends JpaRepository<Members, Long> {
        Optional<Members> findByMemberName(String name);
    }
  learner_created: true
- name: src/splitter/service/GroupService.java
  visible: true
  text: |
    package splitter.service;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    import splitter.entity.Groups;
    import splitter.entity.Members;
    import splitter.repository.GroupsRepository;
    import splitter.repository.MembersRepository;

    import java.util.*;
    import java.util.stream.Collectors;

    /**
     * Service class for working with groups and members.
     */

    @Service
    public class GroupService {

        private final GroupsRepository groupsRepository;
        private final MembersRepository membersRepository;

        @Autowired
        public GroupService(GroupsRepository groupsRepository, MembersRepository membersRepository) {
            this.groupsRepository = groupsRepository;
            this.membersRepository = membersRepository;
        }

        /**
         * Creates a new group and adds members to it if a group with the same name does not exist.
         */

        @Transactional
        public void createGroup(String groupName, Set<String> members) {
            Groups group = groupsRepository.getByGroupName(groupName);
            if (group != null) {
                deleteGroup(group);
                groupsRepository.flush();
            }
            Groups newGroup = groupsRepository.save(new Groups(groupName));
            for (String name : members) {
                Optional<Members> existsMember = membersRepository.findByMemberName(name);
                if (existsMember.isPresent()) {
                    Members member = existsMember.get();
                    member.getGroups().add(newGroup);
                    newGroup.getMembers().add(member);
                } else {
                    Members newMember = membersRepository.save(new Members(name));
                    newMember.getGroups().add(newGroup);
                    newGroup.getMembers().add(newMember);
                }
            }
            groupsRepository.save(newGroup);
        }

        public void deleteGroup(Groups group) {
            groupsRepository.delete(group);
        }


        /**
         * Adds members to an existing group if a group with the specified name exists.
         */

        @Transactional
        public void updateGroup(String groupName, Set<String> members) {
            Optional<Groups> existingGroup = groupsRepository.findByGroupName(groupName);
            if (existingGroup.isPresent()) {
                Groups group = existingGroup.get();
                members.forEach(name -> {
                    Optional<Members> findMember = membersRepository.findByMemberName(name);
                    Members member = findMember.orElseGet(() -> membersRepository.save(new Members(name)));
                    group.getMembers().add(member);
                    groupsRepository.save(group);
                });
            } else {
                System.out.println("Group doesn't exist");
            }
        }


        /**
         * Removes a group and/or members from the group if they no longer belong to any group.
         */

        @Transactional
        public void removeFromGroup(String groupName, Set<String> membersSet) {
            Optional<Groups> existingGroup = groupsRepository.findByGroupName(groupName);
            if (existingGroup.isPresent()) {
                Groups group = existingGroup.get();
                if (membersSet.isEmpty()) {
                    Set<Members> members = group.getMembers();
                    members.forEach(it -> {
                        if (it.getGroups().contains(group) && it.getGroups().size() == 1) {
                            it.getGroups().remove(group);
                        }
                    });
                    group.getMembers().clear();
                    groupsRepository.delete(group);
                } else {
                    Set<Members> membersToRemove = group.getMembers().stream()
                            .filter(member -> membersSet.contains(member.getMemberName()))
                            .collect(Collectors.toSet());
                    group.getMembers().removeAll(membersToRemove);
                    membersToRemove.forEach(member -> {
                        member.getGroups().remove(group);
                        membersRepository.save(member);
                    });
                    groupsRepository.save(group);

                }
            } else {
                System.out.println("Group doesn't exist");
            }
        }

        /**
         * Displays a list of members for the specified group.
         */

        @Transactional
        public void showGroup(String groupName) {
            Optional<Groups> existingGroup = groupsRepository.findByGroupName(groupName);
            if (existingGroup.isPresent()) {
                Groups group = existingGroup.get();
                Set<Members> members = group.getMembers();
                List<String> memberName = new ArrayList<>();
                if (!members.isEmpty()) {
                    members.forEach(member -> memberName.add(member.getMemberName()));
                    Collections.sort(memberName);
                    memberName.forEach(System.out::println);
                } else {
                    System.out.println("Group is empty");
                }
            } else {
                System.out.println("Unknown group");
            }
        }

        @Transactional
        public Set<String> ungroupNames(List<String> groupList) {
            Set<String> namesFromGroup = new HashSet<>();
            for (String groupName : groupList) {
                Optional<Groups> existingGroup = groupsRepository.findByGroupName(groupName);
                if (existingGroup.isPresent()) {
                    Groups group = existingGroup.get();
                    Set<Members> members = group.getMembers();
                    if (members.isEmpty()) {
                        System.out.println("Group is empty");
                    } else {
                        for (Members member : members) {
                            namesFromGroup.add(member.getMemberName());
                        }
                    }
                } else {
                    System.out.println("Group does not exist");
                }
            }
            return namesFromGroup;
        }
    }
  learner_created: true
- name: src/splitter/SecretSantaApplication.java
  visible: true
  text: |
    package splitter;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class SecretSantaApplication {
        public static void main(String[] args) {
            SpringApplication.run(SecretSantaApplication.class, args);
        }
    }
    //    group create BOBTEAM (Frank, Bob)
    //    group create AGROUP (Bob, -Bob)
    //    purchase Ann coffee 12.00 (Chuck, Ann, Bob)
    //    balance close (Bob, Ann)
  learner_created: true
- name: src/splitter/repository/BalanceRepository.java
  visible: true
  text: |
    package splitter.repository;

    import org.springframework.data.jpa.repository.JpaRepository;
    import org.springframework.data.jpa.repository.Query;
    import org.springframework.data.repository.query.Param;
    import splitter.entity.Balance;
    import splitter.entity.Members;

    import java.math.BigDecimal;
    import java.time.LocalDate;
    import java.util.List;

    public interface BalanceRepository extends JpaRepository<Balance, Long> {

        void deleteByDateLessThanEqual(LocalDate date);

        @Query("SELECT b.amount FROM Balance b WHERE b.fromMember = :personOne AND b.toMember = :personTwo ORDER BY b.date DESC, b.balanceId DESC")
        List<BigDecimal> findCurrentAmount(@Param("personOne") Members personOne, @Param("personTwo") Members personTwo);
    }
  learner_created: true
- name: src/splitter/parser/BorrowRepayParser.java
  visible: true
  text: |
    package splitter.parser;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Component;
    import splitter.Command;
    import splitter.CommandProcessor;
    import splitter.service.BorrowRepayService;
    import splitter.util.DateUtil;

    import java.math.*;
    import java.time.LocalDate;
    import java.util.*;

    @Component
    public class BorrowRepayParser implements CommandProcessor {

        private final BorrowRepayService borrowRepayService;

        @Autowired
        public BorrowRepayParser(BorrowRepayService borrowRepayService) {
            this.borrowRepayService = borrowRepayService;
        }

        @Override
        public List<Command> getCommand() {
            return List.of(Command.borrow, Command.repay);
        }

        @Override
        public void process(List<String> input) {
            try {
                LocalDate date = LocalDate.now();
                int commandIndex = 0;

                if (DateUtil.isDate(input.get(0))) {
                    date = DateUtil.getDate(input.get(0));
                    commandIndex = 1;
                }

                Command command = Command.of(input.get(commandIndex));

                if (Command.borrow == command || Command.repay == command) {
                    String personOne = extractPersonOne(input, commandIndex);
                    String personTwo = extractPersonTwo(input, commandIndex);
                    BigDecimal amount = new BigDecimal(extractAmount(input, commandIndex)).setScale(2, RoundingMode.HALF_EVEN);
                    borrowRepayService.process(date, command, amount, personOne, personTwo);
                }
            } catch (Exception e) {
                System.out.println("Illegal command arguments");

            }
        }

        private String extractPersonOne(List<String> input, int commandIndex) {
            return input.get(commandIndex + 1);
        }

        private String extractPersonTwo(List<String> input, int commandIndex) {
            return input.get(commandIndex + 2);
        }

        private String extractAmount(List<String> input, int commandIndex) {
            return input.get(commandIndex + 3);
        }

    }
  learner_created: true
- name: src/splitter/parser/PurchaseCashbackParser.java
  visible: true
  text: |+
    package splitter.parser;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Component;
    import splitter.Command;
    import splitter.CommandProcessor;
    import splitter.service.CashbackService;
    import splitter.service.GroupService;
    import splitter.service.PurchaseService;
    import splitter.util.*;
    import java.math.*;
    import java.time.LocalDate;

    import java.util.*;
    import java.util.function.Consumer;
    import java.util.regex.*;
    import java.util.stream.*;

    @Component
    public class PurchaseCashbackParser implements CommandProcessor {

        private final GroupService groupService;
        private final PurchaseService purchaseService;
        private final CashbackService cashbackService;

        @Autowired
        public PurchaseCashbackParser(GroupService groupService, PurchaseService purchaseService, CashbackService cashbackService) {
            this.groupService = groupService;
            this.purchaseService = purchaseService;
            this.cashbackService = cashbackService;
        }

        @Override
        public List<Command> getCommand() {
            return List.of(Command.purchase, Command.cashBack);
        }

        @Override
        public void process(List<String> input) {
            try {
                LocalDate date = LocalDate.now();
                int commandIndex = 0;

                if (DateUtil.isDate(input.get(0))) {
                    date = DateUtil.getDate(input.get(0));
                    commandIndex = 1;
                }
                Command command = Command.of(input.get(commandIndex));
                String payerMember = input.get(commandIndex + 1);
                BigDecimal totalPrice = new BigDecimal(input.get(commandIndex + 3)).setScale(2, RoundingMode.DOWN);

                Set<String> temporary = new TreeSet<>();
                process(input, commandIndex, RegexPatterns.PLUS_PATTERN, temporary::addAll);
                process(input, commandIndex, RegexPatterns.MINUS_PATTERN, temporary::removeAll);

                switch (command) {
                    case purchase -> purchaseService.process(date, payerMember, totalPrice, temporary);
                    case cashBack -> cashbackService.process(date, payerMember, totalPrice, temporary);
                }
            } catch (Exception e) {
                e.printStackTrace();
                System.out.println("Illegal command arguments");
            }
        }

        private void process(List<String> input, int index, Pattern PATTERN, Consumer<List<String>> action) {
            Map<Boolean, List<String>> map = input.stream()
                    .skip(index + 4)
                    .flatMap(it -> PATTERN.matcher(it).results())
                    .map(MatchResult::group)
                    .collect(Collectors.partitioningBy(it -> RegexPatterns.GROUP_PATTERN.matcher(it).matches()));

            List<String> gropList = map.getOrDefault(true, Collections.emptyList());
            Set<String> namesFromGroup = groupService.ungroupNames(gropList);

            List<String> names = map.getOrDefault(false, Collections.emptyList());
            List<String> finalNames = new ArrayList<>();
            finalNames.addAll(names);
            finalNames.addAll(namesFromGroup);
            action.accept(finalNames);
        }
    }

  learner_created: true
- name: src/splitter/CommandProcessor.java
  visible: true
  text: |
    package splitter;

    import splitter.Command;

    import java.util.Collections;
    import java.util.List;

    @FunctionalInterface
    public interface CommandProcessor {

        void process(List<String> input);

        default List<Command> getCommand() {
            return Collections.emptyList();
        }
    }
  learner_created: true
- name: src/splitter/service/CashbackService.java
  visible: true
  text: |-
    package splitter.service;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    import splitter.AmountCalculator;
    import splitter.entity.Balance;
    import splitter.entity.Members;
    import splitter.entity.Transactions;
    import splitter.repository.BalanceRepository;
    import splitter.repository.MembersRepository;
    import splitter.repository.TransactionsRepository;

    import java.math.BigDecimal;
    import java.time.LocalDate;
    import java.util.*;

    @Service
    public class CashbackService {

        private final BalanceRepository balanceRepository;
        private final MembersRepository membersRepository;
        private final TransactionsRepository transactionsRepository;
        private final BalanceService balanceService;

        @Autowired
        public CashbackService(BalanceRepository balanceRepository, MembersRepository membersRepository, BorrowRepayService borrowRepayService, TransactionsRepository transactionsRepository, BalanceService balanceService) {
            this.balanceRepository = balanceRepository;
            this.membersRepository = membersRepository;
            this.transactionsRepository = transactionsRepository;
            this.balanceService = balanceService;
        }

        @Transactional
        public void process(LocalDate date, String payerMember, BigDecimal totalPrice, Set<String> temporary) {
            BigDecimal quantityPerson = new BigDecimal(temporary.size());
            AmountCalculator calculator = new AmountCalculator(totalPrice, temporary, payerMember);

            BigDecimal sharedAmount = calculator.calcSharedAmount(quantityPerson);
            boolean haveRemainder = calculator.hasRemainder(sharedAmount, quantityPerson);
            Deque<String> extraPayers = calculator.calcExtraPayers(haveRemainder, sharedAmount, quantityPerson);

            Optional<Members> findCompany = membersRepository.findByMemberName(payerMember);
            Members company = findCompany.orElseGet(() -> membersRepository.save(new Members(payerMember))); // to

            temporary.forEach(name -> {
                //name - from
                Optional<Members> findPerson = membersRepository.findByMemberName(name);
                Members person = findPerson.orElseGet(() -> membersRepository.save(new Members(name)));

                BigDecimal currentAmount = balanceService.getCurrentAmount(person, company);
                BigDecimal newAmount = currentAmount.subtract(sharedAmount);
                if (haveRemainder && name.equals(extraPayers.peek())) {
                    newAmount = newAmount.subtract(calculator.getMinimumAmount());
                    extraPayers.remove();
                }
                balanceRepository.save(new Balance(person, company, date, newAmount));
                transactionsRepository.save(new Transactions("cashback", date, person, company, newAmount));
            });
        }
    }
  learner_created: true
- name: testDB.mv.db.mv.db
  visible: true
  learner_created: true
- name: src/splitter/repository/GroupsRepository.java
  visible: true
  text: |
    package splitter.repository;

    import org.springframework.data.jpa.repository.JpaRepository;
    import splitter.entity.Groups;

    import java.util.Optional;

    public interface GroupsRepository extends JpaRepository<Groups, Long> {

        Optional<Groups> findByGroupName(String groupName);
        Groups getByGroupName(String groupName);

    }
  learner_created: true
- name: src/splitter/util/NameKey.java
  visible: true
  text: |
    package splitter.util;

    import java.util.stream.Collectors;
    import java.util.stream.Stream;

    public record NameKey(String personOne, String personTwo) {

        public static boolean isKeyEquals(String personOne, String personTwo) {
            String sortedKey = Stream.of(personOne, personTwo)
                    .sorted()
                    .collect(Collectors.joining());
            String inputKey = personOne + personTwo;
            return sortedKey.equals(inputKey);
        }
    }
  learner_created: true
- name: src/splitter/service/PurchaseService.java
  visible: true
  text: |+
    package splitter.service;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    import splitter.util.NameKey;
    import splitter.AmountCalculator;
    import splitter.entity.Balance;
    import splitter.entity.Members;
    import splitter.entity.Transactions;
    import splitter.repository.BalanceRepository;
    import splitter.repository.MembersRepository;
    import splitter.repository.TransactionsRepository;

    import java.math.*;
    import java.time.LocalDate;
    import java.util.*;

    @Service
    public class PurchaseService {

        private final BalanceRepository balanceRepository;
        private final MembersRepository membersRepository;
        private final TransactionsRepository transactionsRepository;
        private final BalanceService balanceService;

        @Autowired
        public PurchaseService(BalanceRepository balance, MembersRepository members, TransactionsRepository transactions, BalanceService balanceService) {
            this.balanceRepository = balance;
            this.membersRepository = members;
            this.transactionsRepository = transactions;
            this.balanceService = balanceService;
        }

        @Transactional
        public void process(LocalDate date, String payerPerson, BigDecimal totalPrice, Set<String> temporary) {
            BigDecimal quantityPerson = new BigDecimal(temporary.size()); // 3 count members of transaction
            AmountCalculator calculator = new AmountCalculator(totalPrice, temporary, payerPerson);

            BigDecimal sharedAmount = calculator.calcSharedAmount(quantityPerson);
            boolean haveRemainder = calculator.hasRemainder(sharedAmount, quantityPerson);
            Deque<String> extraPayers = calculator.calcExtraPayers(haveRemainder, sharedAmount, quantityPerson);
            extraPayers.remove(payerPerson);

            Optional<Members> findPayerPerson = membersRepository.findByMemberName(payerPerson);
            Members personOne = findPayerPerson.orElseGet(() -> membersRepository.save(new Members(payerPerson)));

            temporary.stream()
                    .sorted()
                    .filter(name -> !name.equals(payerPerson))
                    .forEach(name -> {
                        Optional<Members> findPersonTwo = membersRepository.findByMemberName(name);
                        Members personTwo = findPersonTwo.orElseGet(() -> membersRepository.save(new Members(name)));

                        boolean keyEquals = NameKey.isKeyEquals(payerPerson, name);
                        var mainPerson = keyEquals ? personOne : personTwo;
                        var secondPerson = keyEquals ? personTwo : personOne;

                        BigDecimal currentAmount = balanceService.getCurrentAmount(mainPerson, secondPerson);

                        BigDecimal newAmount;
                        newAmount = keyEquals ? currentAmount.subtract(sharedAmount) : currentAmount.add(sharedAmount);

                        if (haveRemainder && !extraPayers.isEmpty()) {
                            newAmount = keyEquals ? newAmount.subtract(calculator.getMinimumAmount()) : newAmount.add(calculator.getMinimumAmount());
                            extraPayers.remove();

                        }
                        balanceRepository.save(new Balance(mainPerson, secondPerson, date, newAmount));
                        transactionsRepository.save(new Transactions("purchase", date, personTwo, personOne, newAmount));
                    });
        }
    }






  learner_created: true
- name: src/splitter/service/WriteOffService.java
  visible: true
  text: |
    package splitter.service;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    import splitter.Command;
    import splitter.CommandProcessor;
    import splitter.repository.BalanceRepository;
    import splitter.repository.TransactionsRepository;
    import splitter.util.DateUtil;

    import java.time.LocalDate;
    import java.util.Collections;
    import java.util.List;

    @Service
    public class WriteOffService implements CommandProcessor {

        private final BalanceRepository balanceRepository;
        private final TransactionsRepository transactionsRepository;

        @Autowired
        public WriteOffService(BalanceRepository balanceRepository, TransactionsRepository transactionsRepository) {
            this.balanceRepository = balanceRepository;
            this.transactionsRepository = transactionsRepository;
        }

        @Override
        @Transactional
        public void process(List<String> input) {
            LocalDate date = DateUtil.isDate(input.get(0)) ? DateUtil.getDate(input.get(0)) : LocalDate.now();
            balanceRepository.deleteByDateLessThanEqual(date);
            transactionsRepository.deleteByDateLessThanEqual(date);

        }

        @Override
        public List<Command> getCommand() {
            return Collections.singletonList(Command.writeOff);
        }
    }
  learner_created: true
- name: src/splitter/service/PerfectService.java
  visible: true
  learner_created: true
- name: src/splitter/entity/Balance.java
  visible: true
  text: |
    package splitter.entity;

    import javax.persistence.*;
    import java.math.BigDecimal;
    import java.time.LocalDate;

    @Entity
    public class Balance {

        @Id
        @GeneratedValue(strategy = GenerationType.IDENTITY)
        @Column(name = "balance_id")
        private Long balanceId;

        @ManyToOne
        @JoinColumn(name = "from_member_id")
        private Members fromMember;

        @ManyToOne
        @JoinColumn(name = "to_member_id")
        private Members toMember;

        private LocalDate date;

        private BigDecimal amount;

        public Balance(Members fromMember, Members toMember, LocalDate date, BigDecimal amount) {
            this.fromMember = fromMember;
            this.toMember = toMember;
            this.date = date;
            this.amount = amount;
        }

        public Balance() {}

        public Members getFromMember() {
            return fromMember;
        }

        public Members getToMember() {
            return toMember;
        }

        public LocalDate getDate() {
            return date;
        }

        public BigDecimal getAmount() {
            return amount;
        }

        @Override
        public String toString() {
            return "Balance {" +
                    "balanceId= " + balanceId +
                    ", fromMember= " + fromMember +
                    ", toMember= " + toMember +
                    ", date= " + date +
                    ", amount= " + amount +
                    '}';
        }
    }
  learner_created: true
- name: src/splitter/ResultsHolder.java
  visible: true
  learner_created: true
- name: testDB97.mv.db.mv.db
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/11723#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">Hyperskill</a>
    to continue learning.
  time: "Sun, 01 Oct 2023 04:46:55 UTC"
record: -1
